1<ol class='xoxo'>
  <li>数组与内存控制- 为什么说java数组是静态的？  + 数组被初始化后，长度不可变- 数组初始化的两种方式  + 静态初始化和动态初始化</li>
  <li>对象与内存控制- 变量的分类  + 分为成员变量和局部变量，局部变量还分为形参，方法内的局部变量和代码块内的局部变量- 静态变量与非静态变量的内存分配  静态变量只被分配一块内存空间- 可以在哪些场景下初始化非静态变量  定义实例变量时，非静态初始化块中，构造器中- 可以在哪些场景下初始化静态变量  定义类变量时，静态初始化块中- 类初始化的过程  先调用每个父类非静态初始化块，父类构造器执行初始化，再调用本类的非静态初始化块，构造器执行初始化- 子类调用父类构造器的情形  子类初始化时，先调用父类的构造方法  + 父类构造方法中调用已经被子类重写的方法，用this.表示是调用正在进行初始化的那个对象- 父类对象调用子类对象方法的场景  + 子類初始化時，先調用父類的構造方法  + 父類構造方法中調用已被子類重寫的方法  + 此時調用的方法，不是父類中的而是子類中的- 內存中子類實例  + 噹通過引用變量來訪問它所引用對象的實例變量時，該實例變量的值取決于聲明該變量時所用的類型  + 程序創建一個子類對象時，系統不僅為該類中定義的實例變量分配內存，也會為其父類中定義的所有實例變量分配內存，即使子類定義了與父類中同名的實例變量- 父子类的静态变量 子类会隐藏父类的类变量，如果要访问，则直接使用父类或super调用- 编译器在处理方法和成员是存在的区别- 构造器中this代表哪个对象? 正在初始化的对象- 子类构造函数执行的顺序 父类的构造函数 --》子类的构造函数 如果子类重写了父类的方法，则先执行子类的方法- java对象何时赋初值- java对象何时分配内存- 继承成员变量与继承成员方法的区别  + 方法的行为总是体现实际类型的行为  + 实例变量的值总是体现变量所用类型的行为- 父类的实例变量和子类的实例变量都保存在内存中- java程序不允许方法返回super或把super当作变量使用- 父、子对象内存中的存储问题  + 系统会为父子类对象的实例变量分配内存  + 如果子类对象的实例变量与父类相同，子类对象会隐藏父类对象的实例变量- final修饰变量时，可能指定初始化值的三个位置  + 定义final实例变量时指定初始值  + 在非静态初始化块中为final实例变量指定初始值  + 在构造器中为final实例变量指定初始值- final类变量必须被显式地被赋初始值,且以后不能再改变- final类变量指定初始值的情形 + 定义final变量时指定初始值 + 在静态初始化块中为final类变量进行初始化- final类变量特点 + 修饰类变量时，定义final类变量时指定初始值后在编译时就被确定下来，系统不会在静态初始化中对该变量赋值 + 修饰变量时，如果定义该final变量时就指定初始值，变量将成为一个宏变量，在静态初始化块中却不会- final方法不能被重写 + 父类的方法被final修饰后，不能被子类重写 + 如果父类方法被final修饰，子类中的同名方法不再是重写父类的方法- 内部类中局部变量 + 如果程序需要在内部类中使用局部变量，此变量必须使用final修饰</li>
  <li>常见java集合的实现细节
    <ol>
      <li>set和Map
	<ol>
	  <li>Set 和 Map的关系- Map集合是set集合的扩展</li>
	  <li>HashMap 和 HashSet- 系统采用Hash算法来决定每个元素的位置- 集合中的对象实际上保存的是对象的引用- HashMap的绝大部分方法是通过调用HashMap的方法来实现的- 两个集合在本质上是相同的
	    <ol>
	      <li>HashMap- 创建一个hashMap时，会自动创建一个table数组来保存HashMap中的Entry- 初始化HashMap时，系统会创建一个长度为capacity的Entry数组</li>
	      <li>HashSet- 只是封装了一个HashMap对象来存储所有的集合元素- 如果封装的对象实现的hashCode()和equals()方法，则会根据自定义的规则比较对象的值- </li>
	    </ol>
	  </li>
	  <li>Tree和TreeSet- TreeSet底层采用一个NavigableMap来保存集合的元素- NavigableMap接口的具体实现类是TreeMap- TreeSet和TreeMap是基于红黑二叉树的一种排序集合,key会从小到大的顺序排列- 添加元素和取出元素的性能比Hash要低- 优势是自动平衡排序
	    <ol>
	      <li>排序二叉树的性质- 若它的左树不空，则左子树上所有的节点的值均小于根节点的值- 若右子树不空，则右子树上所有节点的值均大于根节点的值- 子树也是排序二叉树</li>
	      <li>红黑树的性质- 每个节点只有红或黑- 根节点是黑- 叶节点是空节点null,且黑- 每个红色节点的两个节点的是黑色的- 从任一个节点到其子节点的路径都包含相同数量的黑色节点- 对于给定的黑色高度为 N 的红黑树，从根到叶子节点的最短路径长度为 N-1，最长路径长度为 2 * (N-1)</li>
	    </ol>
	  </li>
	</ol>
      </li>
      <li>Map和List
	<ol>
	  <li>Map的values()方法</li>
	</ol>
      </li>
      <li>ArrayList和LinkedList</li>
      <li>迭代器</li>
    </ol>
  </li>
  <li>Java的内存回收
    <ol>
      <li>java引用的种类</li>
      <li>java的内存泄漏</li>
      <li>垃圾回收机制</li>
      <li>内存管理的小技巧</li>
    </ol>
  </li>
  <li>表达式中的陷阱
    <ol>
      <li>字符中次的陷阱</li>
      <li>表达式类型的陷阱</li>
      <li>输入法导致的陷阱</li>
      <li>注释的字符必须合法</li>
      <li>转义字符的陷阱</li>
      <li>泛型可能引起的错误</li>
      <li>正则表达式的陷阱</li>
      <li>多线程的陷阱</li>
    </ol>
  </li>
  <li>流程控制的陷阱
    <ol>
      <li>switch语句陷阱</li>
      <li>标签引起的陷阱</li>
      <li>if语句的陷阱</li>
      <li>循环体的花括号</li>
      <li>for循环的陷阱</li>
    </ol>
  </li>
</ol>
